package org.agmas.harpymodloader;

import dev.doctor4t.wathe.api.GameMode;
import dev.doctor4t.wathe.api.Role;
import dev.doctor4t.wathe.api.WatheGameModes;
import dev.doctor4t.wathe.api.WatheRoles;
import dev.doctor4t.wathe.client.gui.RoleAnnouncementTexts;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.command.v2.ArgumentTypeRegistry;
import net.fabricmc.fabric.api.command.v2.CommandRegistrationCallback;
import net.minecraft.command.argument.serialize.ConstantArgumentSerializer;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.text.MutableText;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;
import org.agmas.harpymodloader.commands.ForceModifierCommand;
import org.agmas.harpymodloader.commands.ForceRoleCommand;
import org.agmas.harpymodloader.commands.ListRolesCommand;
import org.agmas.harpymodloader.commands.SetEnabledModifierCommand;
import org.agmas.harpymodloader.commands.SetEnabledRoleCommand;
import org.agmas.harpymodloader.commands.argument.ModifierArgumentType;
import org.agmas.harpymodloader.commands.argument.RoleArgumentType;
import org.agmas.harpymodloader.config.HarpyModLoaderConfig;
import org.agmas.harpymodloader.modded_murder.ModdedMurderGameMode;
import org.agmas.harpymodloader.modded_murder.ModdedWeights;
import org.agmas.harpymodloader.modifiers.HMLModifiers;
import org.agmas.harpymodloader.modifiers.Modifier;

public class Harpymodloader implements ModInitializer {

    public static HashMap<Identifier, Integer> ROLE_MAX = new HashMap<>();
    public static HashMap<Identifier, Integer> MODIFIER_MAX = new HashMap<>();

    public static HashMap<Role, List<UUID>> FORCED_MODDED_ROLE = new HashMap<>();
    public static HashMap<UUID, Role> FORCED_MODDED_ROLE_FLIP = new HashMap<>();

    public static HashMap<Modifier, List<UUID>> FORCED_MODDED_MODIFIER = new HashMap<>();

    public static ArrayList<Role> VANNILA_ROLES = new ArrayList<>();
    public static ArrayList<Role> SPECIAL_ROLES = new ArrayList<>();
    public static ArrayList<Role> OVERWRITE_ROLES = new ArrayList<>();
    public static String MOD_ID = "harpymodloader";

    public static GameMode MODDED_GAMEMODE;
    public static boolean wantsToStartVannila = false;

    public static HashMap<Role, RoleAnnouncementTexts.RoleAnnouncementText> autogeneratedAnnouncements = new HashMap<>();
    public static HashMap<RoleAnnouncementTexts.RoleAnnouncementText, Role> autogeneratedAnnouncements_flip = new HashMap<>();

    @Override
    public void onInitialize() {
        HarpyModLoaderConfig.HANDLER.load();
        VANNILA_ROLES.add(WatheRoles.LOOSE_END);
        VANNILA_ROLES.add(WatheRoles.CIVILIAN);
        VANNILA_ROLES.add(WatheRoles.KILLER);
        VANNILA_ROLES.add(WatheRoles.VIGILANTE);
        VANNILA_ROLES.add(WatheRoles.DISCOVERY_CIVILIAN);

        SPECIAL_ROLES.add(WatheRoles.LOOSE_END);
        SPECIAL_ROLES.add(WatheRoles.DISCOVERY_CIVILIAN);
        SPECIAL_ROLES.add(WatheRoles.CIVILIAN); // civilian is considered special since it can't be assigned, just given out to everyone

        OVERWRITE_ROLES.add(WatheRoles.CIVILIAN);
        OVERWRITE_ROLES.add(WatheRoles.KILLER);

        ModdedWeights.init();

        registerCommands();
        HMLModifiers.init();

        MODDED_GAMEMODE = WatheGameModes.registerGameMode(Identifier.of(MOD_ID, "modded"), new ModdedMurderGameMode(Identifier.of(MOD_ID, "modded")));

        refreshRoles();
    }

    //
    // re-indexes roles
    //
    public static void refreshRoles() {
        for (Role role : WatheRoles.ROLES) {
            if (SPECIAL_ROLES.contains(role)) continue;
            if (!ModdedWeights.roleRounds.containsKey(role)) {
                ModdedWeights.roleRounds.put(role, new HashMap<>());
                ModdedWeights.roleWeights.put(role, new HashMap<>());

                RoleAnnouncementTexts.RoleAnnouncementText roleAnnouncementText = new RoleAnnouncementTexts.RoleAnnouncementText(role.identifier().toTranslationKey(), role.color());
                autogeneratedAnnouncements.put(role, roleAnnouncementText);
                autogeneratedAnnouncements_flip.put(roleAnnouncementText, role);
                RoleAnnouncementTexts.registerRoleAnnouncementText(roleAnnouncementText);
            }
        }
    }

    public static void addToForcedModifiers(Modifier modifier, PlayerEntity player) {
        if (!FORCED_MODDED_MODIFIER.containsKey(modifier)) FORCED_MODDED_MODIFIER.put(modifier, new ArrayList<>());
        FORCED_MODDED_MODIFIER.get(modifier).add(player.getUuid());

    }

    public static void addToForcedRoles(Role role, PlayerEntity player) {
        if (!FORCED_MODDED_ROLE.containsKey(role)) FORCED_MODDED_ROLE.put(role, new ArrayList<>());
        FORCED_MODDED_ROLE.get(role).add(player.getUuid());

        FORCED_MODDED_ROLE_FLIP.put(player.getUuid(), role);
    }

    public static void setRoleMaximum(Identifier role, Integer max) {
        ROLE_MAX.put(role, max);
    }

    public static void setRoleMaximum(Role role, Integer max) {
        setRoleMaximum(role.identifier(), max);
    }

    public void registerCommands() {
        ArgumentTypeRegistry.registerArgumentType(
                Identifier.of(MOD_ID, "role"),
                RoleArgumentType.class,
                new RoleArgumentType.Serializer()
        );
        ArgumentTypeRegistry.registerArgumentType(
                Identifier.of(MOD_ID, "modifier"),
                ModifierArgumentType.class,
                ConstantArgumentSerializer.of(ModifierArgumentType::create)
        );

        CommandRegistrationCallback.EVENT.register((dispatcher, registryAccess, environment) -> {
            ForceRoleCommand.register(dispatcher);
            SetEnabledRoleCommand.register(dispatcher);
            ListRolesCommand.register(dispatcher);
            ForceModifierCommand.register(dispatcher);
            SetEnabledModifierCommand.register(dispatcher);
        });
    }

    public static MutableText getRoleName(Role role) {
        // vanilla
        if (role.identifier().getNamespace().equalsIgnoreCase("wathe")) {
            return Text.translatable("announcement.role." + role.identifier().getPath());
        }
        return Text.translatable("announcement.role." + role.identifier().toTranslationKey());
    }
}
